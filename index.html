<!DOCTYPE html>
<html>

<head>
    <title>Bannergress Banner Mapper</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: sans-serif;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .flex-container {
            display: flex;
            height: 100%;
        }

        #map {
            flex-grow: 1;
        }

        .nav-area {
            width: 200px;
            /* Adjust as needed */
            background-color: #f8f9fa;
            padding: 1em;
            box-shadow: -1px 0 5px rgba(0, 0, 0, 0.1);
        }

        .nav-area button {
            margin-top: 1em;
            width: 100%;
        }

        .leaflet-popup-content img {
            max-width: 300px;
        }

        #show-banners {
            position: relative;
        }

        #loading-spinner {
            display: none;
            border: 5px solid #0099ff;
            border-top: 5px solid #000000;
            border-radius: 50%;
            width: 5px;
            height: 5px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div class="flex-container">

        <div id="map"></div>
        <div class="nav-area">
            <p>This page can display lots of banners from <a href="https://bannergress.com"
                    target="_blank">Bannergress</a> on a single
                map at the same time.</p>
            <p>It can also display all the banners from a place, such as a city or a country, by pasting the place's
                "browse" URL below.</p>
            <p>Here are some suggestion:
                <a href="#" class="example-place" data-id="london-6549">London</a>,
                <a href="#" class="example-place" data-id="lisbon-1eae">Lisbon</a>,
                <a href="#" class="example-place" data-id="porto-9b95">Porto</a>,
                <a href="#" class="example-place" data-id="hanover-6716">Hannover</a>, or
                <a href="#" class="example-banners"
                    data-id="recurse-aberdeen-595b,artistic-aberdeen-ca16,resistance-aberdeen-874e">some missions in
                    Aberdeen that make a good route</a>.
            </p>

            <label for="banner-links">Paste your bannergress links here:</label>
            <textarea id="banner-links" style="width: 100%; height: 200px;"></textarea>
            <div>
                <button id="show-banners">
                    Show banners
                    <div id="loading-spinner"></div>
                </button>
                <button id="clear-banners">Clear banners</button>
            </div>

            <p id="unique-portals"></p>

            <p>
                This is not affiliated with Niantic, Inc., Ingress, or Bannergress. Raise issues on <a
                    href="https://github.com/simbabque/ingress-banner-mapper/issues">Github</a>.
            </p>
        </div>

        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script src="https://unpkg.com/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.js"></script>
        <script src="https://unpkg.com/leaflet-svg-shape-markers@1.4.0/dist/leaflet-svg-shape-markers.js"></script>
        <script>

            // Initialise the map - we start in London
            let map = L.map('map').setView([51.505, -0.09], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Stores the count of unique lat/long pairs to show UPV
            let uniqueLatLongPairs = {};

            // FeatureGroup to keep all banners visible
            const allBanners = L.featureGroup();
            let allBannersByBannerId = {};

            // Event listener for the "Show banners" button
            async function showBanners() {
                // Show the loading spinner
                document.getElementById('loading-spinner').style.display = 'inline-block';

                const urlsToFetch = [];
                for (const url of document.getElementById("banner-links").value.split('\n')) {
                    // ignore if it doesn't look like a bannergress.com url
                    if (!url.includes('bannergress.com')) {
                        continue;
                    }

                    // if it's a browse url, resolve it to the list of banners
                    if (url.includes('/browse/')) {
                        const banners = await resolvePlaceURL(url);
                        urlsToFetch.push(...banners);
                    } else {
                        urlsToFetch.push(url);
                    }
                }

                // Fetch all URLs concurrently
                Promise.all(urlsToFetch.map(url => fetchJsonData(apiURL(url))))
                    .then(dataArray => {
                        if (dataArray.length) {
                            allBanners.addTo(map);
                            map.fitBounds(allBanners.getBounds());
                        }

                        // Hide the loading spinner
                        document.getElementById('loading-spinner').style.display = 'none';

                        // Display the count of UPV
                        updateUniquePortalCount();
                    })
                    .catch(error => {
                        console.error('One or more fetch calls failed:', error);

                        // Hide the loading spinner
                        document.getElementById('loading-spinner').style.display = 'none';
                    });
            }
            document.getElementById("show-banners").addEventListener("click", showBanners);

            let isPopupOpen = false;

            // When a popup opens, decrease the opacity of all other banners
            // known issue: panning the map while a popup is open restores the arrow-head opacity
            map.on('popupopen', function (e) {
                isPopupOpen = true;

                // find the banner polyline to highlight
                const activePolyline = e.popup._source._banner_id ? allBannersByBannerId[e.popup._source._banner_id].polyline : Object.values(allBannersByBannerId).find(banner => banner.polyline.associatedLayers.includes(e.popup._source)).polyline;

                // decrease the opacity of all other banners
                Object.values(allBannersByBannerId).forEach(banner => {
                    const opacity = banner.polyline === activePolyline ? fullOpacity : lowOpacity;
                    banner.polyline.setStyle({ opacity: opacity, fillOpacity: opacity });
                    banner.polyline.associatedLayers.forEach(layer => {
                        layer.setStyle({ opacity: opacity, fillOpacity: opacity });
                    });

                    // fiddle with the arrow-head opacity in the actual polylineDecorator
                    banner.polyline.associatedLayers[0].options.patterns[0].symbol.options.pathOptions.opacity = opacity;
                });
            });

            // When a popup closes, restore the opacity of all banners
            map.on('popupclose', function (e) {
                isPopupOpen = false;

                // find the banner polyline to reset opacity
                const activePolyline = e.popup._source._banner_id ? allBannersByBannerId[e.popup._source._banner_id].polyline : Object.values(allBannersByBannerId).find(banner => banner.polyline.associatedLayers.includes(e.popup._source)).polyline;

                // reset the opacity of all banners
                Object.values(allBannersByBannerId).forEach(banner => {
                    banner.polyline.setStyle({ opacity: regularOpacity, fillOpacity: fullOpacity });
                    banner.polyline.associatedLayers.forEach(layer => {
                        layer.setStyle({ opacity: regularOpacity, fillOpacity: fullOpacity });
                    });

                    // reset the arrow-head opacity in the actual polylineDecorator
                    banner.polyline.associatedLayers[0].options.patterns[0].symbol.options.pathOptions.opacity = regularOpacity;
                });
            });

            // Event listener for the "Clear banners" button
            function clearBanners() {
                allBanners.clearLayers();
                allBanners.remove();
                allBannersByBannerId = {};
                invocationCount = 0;
                uniqueLatLongPairs = {};
                updateUniquePortalCount();
            }
            document.getElementById("clear-banners").addEventListener("click", clearBanners);

            // Event listener for the example places to append their data-id as browse URLs into the textarea in a new line
            document.querySelectorAll('.example-place').forEach(place => place.addEventListener('click', (event) => {
                const textarea = document.getElementById('banner-links');
                textarea.value += `https://bannergress.com/browse/${event.target.dataset.id}\n`;
            }));

            // Event listener for the example banners to append their data-id as banner URLs into the textarea in a new line
            document.querySelectorAll('.example-banners').forEach(place => place.addEventListener('click', (event) => {
                const textarea = document.getElementById('banner-links');
                textarea.value += event.target.dataset.id.split(',').map(id => `https://bannergress.com/banner/${id}`).join('\n') + '\n';
            }));


            // Fill the textarea with the URL parameter 'banners' if it exists
            document.addEventListener("DOMContentLoaded", function () {
                let urlParam;
                if (urlParam = getURLParameter('banners')) {
                    document.getElementById('banner-links').value = urlParam;
                    showBanners();
                } else if (urlParam = getURLParameter('place')) {
                    fetch(`https://api.bannergress.com/places?used=true&collapsePlaces=true&limit=1&offset=0&query=${encodeURIComponent(urlParam)}`)
                        .then(response => response.json())
                        .then(data => {
                            // Get the ID of the first result
                            const id = data[0].id;

                            // Construct the 'browse' URL
                            const browseUrl = `https://bannergress.com/browse/${id}`;

                            // Fill the 'browse' URL into the textarea
                            document.getElementById('banner-links').value = browseUrl;

                            // Trigger the 'Show banners' button click event
                            document.getElementById('show-banners').click();
                        })
                        .catch(error => {
                            console.error('Failed to fetch place:', error);
                        });

                    showBanners();
                }
            });

            // Turn banner URL into API URL
            function apiURL(url) {
                return 'https://api.bannergress.com/bnrs/' + url.split('/').pop();
            }

            // Function to retrieve a single banner JSON and draw it on the map
            let invocationCount = 0;
            function fetchJsonData(url) {
                return fetch(url)
                    .then(response => response.json())
                    .then(data => allBanners.addLayer(drawBanner(data, invocationCount++)))
                    .catch(error => console.error('Error fetching JSON:', error));
            }

            // Function to turn a place into a list of banners
            function resolvePlaceURL(url) {
                // Extract the placeId from the URL
                const placeId = url.split('/').pop();

                // Fetch all banners iteratively using offset
                const fetchAllBanners = async (placeId, offset = 0, banners = []) => {
                    const apiUrl = `https://api.bannergress.com/bnrs?orderBy=created&orderDirection=DESC&online=true&placeId=${placeId}&limit=100&offset=${offset}`;

                    try {
                        const response = await fetch(apiUrl);
                        const data = await response.json();
                        const newBanners = data.map(banner => `https://bannergress.com/banner/${banner.id}`);
                        banners.push(...newBanners);

                        if (data.length === 100) {
                            return fetchAllBanners(placeId, offset + 100, banners);
                        } else {
                            return banners;
                        }
                    } catch (error) {
                        console.error('Error fetching JSON:', error);
                    }
                };

                // Fetch the data
                return fetchAllBanners(placeId);
            }

            // Colours for the banner routes
            const colours = [
                "#B30000", // Dark Red
                "#B35F00", // Dark Orange
                "#0000B3", // Dark Blue
                "#5FB300", // Dark Chartreuse
                "#00B3B3", // Dark Cyan
                "#00B35F", // Dark SpringGreen
                "#005FB3", // Dark Azure
                "#5F00B3", // Dark Violet
                "#B300B3", // Dark Magenta
                "#B3005F", // Dark Rose
                "#B32D00", // Dark OrangeRed
                "#B38C00", // Dark Gold
                "#B36B00", // Dark DarkOrange
                "#5A3A14", // Dark SaddleBrown
                "#267326", // Dark LimeGreen
                "#2D5773", // Dark SteelBlue
                "#662D66", // Dark DarkOrchid
                "#5C1F5C", // Dark BlueViolet
                "#B3B300", // Dark Yellow
                "#00B300", // Dark Lime
            ];

            const lowOpacity = 0.2;
            const regularOpacity = 0.6;
            const fullOpacity = 1;

            // Function to draw a banner on the map
            function drawBanner(bannerData, invocationCount) {
                const colour = colours[invocationCount % colours.length];
                const latLongPairs = [];
                try {
                    Object.values(bannerData.missions).forEach(mission => {
                        mission.steps.forEach(step => {
                            if (step.poi && step.poi.type !== "unavailable") {
                                const { latitude, longitude } = step.poi;
                                latLongPairs.push([latitude, longitude]);

                                // Increment the count for the lat/long pair that's a portal
                                if (step.poi.type === "portal") {
                                    const key = JSON.stringify([latitude, longitude]);
                                    uniqueLatLongPairs[key] = (uniqueLatLongPairs[key] || 0) + 1;
                                }
                            }
                        });
                    });
                } catch (e) {
                    console.log(bannerData);
                    console.error(e);
                };

                // draw a filled circle at the start and end of the banner
                const endMarker = L.shapeMarker(latLongPairs[latLongPairs.length - 1], { shape: 'diamond', color: 'black', opacity: 0.4, fillColor: colour, fillOpacity: fullOpacity }).addTo(allBanners);
                const startMarker = L.circleMarker(latLongPairs[0], { color: 'black', opacity: 0.4, fillColor: colour, fillOpacity: fullOpacity }).addTo(allBanners);
                const polyline = L.polyline(latLongPairs, { color: colour, opacity: regularOpacity }).addTo(allBanners);
                const arrowSymbol = L.polylineDecorator(polyline, {
                    patterns: [
                        {
                            offset: '10', repeat: '50', symbol: L.Symbol.arrowHead({
                                pixelSize: 10, polygon: false, pathOptions: { color: colour, opacity: regularOpacity }
                            })
                        }
                    ]
                }).addTo(allBanners);

                // Give the polyline a unique ID and keep the other bits close to it
                polyline._banner_id = bannerData.id;
                polyline.associatedLayers = [arrowSymbol, startMarker, endMarker];

                // Store the banner data and the associated line and layers for later use
                allBannersByBannerId[bannerData.id] = {
                    bannerData: bannerData,
                    polyline: polyline,
                };

                const popupContent = createPopup(bannerData, polyline);

                polyline.bindPopup(popupContent);
                startMarker.bindPopup(popupContent);
                endMarker.bindPopup(popupContent);

                // Change opacity on hover
                [polyline, arrowSymbol, startMarker, endMarker].forEach(element => {
                    element.on('mouseover', () => {
                        if (isPopupOpen) return;
                        allBanners.eachLayer(layer => {
                            if (layer !== polyline && layer !== arrowSymbol) {
                                layer.setStyle({ opacity: lowOpacity, fillOpacity: lowOpacity });
                            } else {
                                polyline.setStyle({ opacity: fullOpacity });
                                arrowSymbol.setStyle({ opacity: fullOpacity });
                                startMarker.setStyle({ opacity: fullOpacity, fillOpacity: fullOpacity });
                                endMarker.setStyle({ opacity: fullOpacity, fillOpacity: fullOpacity });
                            }
                        });
                    });

                    element.on('mouseout', () => {
                        if (isPopupOpen) return;
                        allBanners.eachLayer(layer => {
                            layer.setStyle({ opacity: regularOpacity, fillOpacity: fullOpacity });
                        });
                    });
                });

                allBanners.addLayer(polyline);
                return polyline;
            }

            // Function to hide a banner
            function hideBanner(id) {
                // Find the polyline with the given ID
                const polyline = allBanners.getLayers().find(layer => layer._banner_id === id);

                // Remove the polyline from the map
                if (polyline && map.hasLayer(polyline)) {
                    allBanners.removeLayer(polyline);
                    polyline.associatedLayers.forEach(layer => {
                        if (map.hasLayer(layer)) {
                            allBanners.removeLayer(layer);
                        }
                    });

                    // Decrement the count for each lat/long pair of the removed banner
                    polyline.getLatLngs().forEach(latlng => {
                        const key = JSON.stringify([latlng.lat, latlng.lng]);
                        uniqueLatLongPairs[key]--;
                        if (uniqueLatLongPairs[key] === 0) {
                            delete uniqueLatLongPairs[key];
                        }
                    });

                    updateUniquePortalCount();
                }
                // Remove the banner from allbannerByBannerId
                delete allBannersByBannerId[id];
            }

            // Function to create a popup for a banner
            function createPopup(bannerData, polyline) {
                const length = Number(bannerData.lengthMeters / 1000).toPrecision(2);

                // Determine the mission type
                let hasSequential = false;
                let hasAnyOrder = false;
                Object.values(bannerData.missions).forEach(mission => {
                    if (mission.type === "sequential") {
                        hasSequential = true;
                    } else if (mission.type === "anyOrder") {
                        hasAnyOrder = true;
                    }
                });

                // Calculate the number of missions per km
                const missionsPerKm = bannerData.numberOfMissions / length;

                // Determine the mission type
                let missionType;
                if (hasSequential && hasAnyOrder) {
                    missionType = "<abbr title='sequential'>S</abbr>/<abbr title='any order'>AO</abbr>";
                } else if (hasSequential) {
                    missionType = "<abbr title='sequential'>S</abbr>";
                } else if (hasAnyOrder) {
                    missionType = "<abbr title='any order'>AO</abbr>";
                } else {
                    missionType = "";
                }

                // Create a zoom link
                const bounds = polyline.getBounds()
                const boundsArray = [
                    [bounds._southWest.lat, bounds._southWest.lng],
                    [bounds._northEast.lat, bounds._northEast.lng]
                ];
                const zoomLink = `<a href="#" onclick="map.fitBounds(${JSON.stringify(boundsArray).replace(/"/g, '&quot;')}); return false;">🔍 zoom to this banner</a>`;

                // Add a popup with the banner title and picture
                return `
    <a href="https://bannergress.com/banner/${bannerData.id}">${bannerData.title}</a> (${length}km, ${missionsPerKm.toPrecision(3)}<abbr title="mission/km">mpk</abbr>, ${missionType})
    <br/>
    ${bannerData.warning ? `⚠️ <span style="color: #ffb21d;">${bannerData.warning}</span><br/>` : ''}
    <img src="https://api.bannergress.com/${bannerData.picture}" width="300">
    <a href="#" onclick="hideBanner('${bannerData.id}'); return false;">❌ hide this banner</a> ${zoomLink}
`;
            }

            // Function to calculate the bounds of a set of lat/long pairs
            function calculateBannerBounds(latLongPairs) {
                return latLongPairs.reduce((bounds, latLong) => bounds.extend(latLong), L.latLngBounds(latLongPairs[0]));
            }

            // Function to update the count of unique portals
            function updateUniquePortalCount() {
                const count = Object.keys(uniqueLatLongPairs).length;
                const uniquePortals = document.getElementById('unique-portals');

                if (count > 0) {
                    uniquePortals.textContent = `Unique portals: ${count}`;
                } else {
                    uniquePortals.textContent = '';
                }
            }

            // Function to get URL parameters
            function getURLParameter(name) {
                return new URLSearchParams(window.location.search).get(name);
            }

        </script>
</body>

</html>